% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sge_accounting.R
\name{read_raw_sge_accounting}
\alias{read_raw_sge_accounting}
\alias{write_raw_sge_accounting}
\alias{as_sge_accounting}
\alias{as_sge_accounting.raw_sge_accounting}
\alias{print.sge_accounting}
\alias{sge_accounting_file}
\alias{read_sge_accounting}
\alias{parse_category}
\alias{parse_category.sge_accounting}
\alias{sge_failed_codes}
\title{Read a tab-delimited SGE accounting file (without parsing it)}
\usage{
read_raw_sge_accounting(
  file,
  offset = 0,
  n_max = Inf,
  skip = if (is.character(file) && offset == 0) 4L else 0L,
  ...
)

write_raw_sge_accounting(x, file, header = attr(x, "header"), ...)

as_sge_accounting(x, ...)

\method{as_sge_accounting}{raw_sge_accounting}(x, ...)

\method{print}{sge_accounting}(x, format = c("pretty", "raw"), ...)

sge_accounting_file(
  filename = "accounting",
  path = do.call(file.path, args = as.list(c(Sys.getenv(c("SGE_ROOT", "SGE_CELL")),
    "common")))
)

read_sge_accounting(file = sge_accounting_file(), ...)

parse_category(x, ...)

\method{parse_category}{sge_accounting}(x, properties = c("h_rt", "s_rt", "mem_free"), ...)

sge_failed_codes()
}
\arguments{
\item{file}{(character) The SGE \file{accounting} file to read.}

\item{offset}{The file offset position (in bytes) from where to start reading.}

\item{n_max}{(numeric) The maximum number of rows to read.}

\item{skip}{(integer) Number of lines to skip before parsing file content.}

\item{x}{An \code{sge_accounting} object.}

\item{header}{(character vector) Zero of more header lines to be written
at the top of the file.}

\item{format}{Either \code{"pretty"} or \code{"raw"}.}

\item{filename}{(character string) The name of the accounting file.}

\item{path}{(character string) The path to the accounting file.}

\item{properties}{(character vector) The properties to extract.}

\item{\ldots}{(optional) Not used.}
}
\value{
(character string) The pathname to the SGE accounting file.
If not found, and error is thrown.

A \code{tibble} data frame with columns:
\itemize{
\item \code{qname} (character) - name of the cluster queue in which the job has run
\item \code{hostname} (character) - name of the execution host
\item \code{group} (character) - the effective group id of the job owner when
executing the job
\item \code{owner} (character) - owner of the Grid Engine job
\item \code{job_name} (character) - job name
\item \code{job_number} (integer) - job identifier
\item \code{account} (character) - an account string as specified by the \code{qsub} or \code{qalter}
\item \code{priority} (integer) - priority value assigned to the job
\item \code{submission_time} (dttm) - submission time
\item \code{start_time} (dttm) - start time
\item \code{end_time} (dttm) - end time
\item \code{failed} (integer) - indicates the problem which occurred in case a job
failed (at the system level, as opposed to the job script or binary having
non-zero exit status).  Indicates the problem which occurred in case a job
could not be started on the execution host (e.g. because the owner of the
job did not have a valid account on that machine). If Sun Grid Engine
tries to start a job multiple times, this may lead to multiple entries in
the accounting file corresponding to the same job ID
\item \code{exit_status} (integer) - exit status of the job script (or Grid
Engine-specific status in case of certain error conditions).
The exit status is determined by following the normal shell conventions.
If the command terminates normally the value of the command is its exit
status. However, in the case that the command exits abnormally, a value
of 0200 (octal), 128 (decimal) is added to the value of the command to
make up the exit status.
For example: If a job dies through signal 9 (\code{SIGKILL}) - probably issued
by Grid Engine through \code{qdel}, or because the job exceeded time or memory
hard limits - then the exit status is 128 + 9 = 137.
\item \code{ru_wallclock} (drtn) - Difference between 'end_time' and 'start_time'
(time interval), except that if the job fails, it is zero.
\item \code{ru_utime} (drtn) - user CPU time (in seconds) used, i.e. total amount of
time spent executing in user mode
\item \code{ru_stime} (drtn) - system CPU time (in seconds) used, i.e. total amount
of time spent executing in kernel mode
\item \code{ru_maxrss} (character) - maximum resident set size (in kB)
\item \code{ru_ixrss} (character) - integral shared memory size (in kB) [UNUSED]
\item \code{ru_ismrss} (character) - ???
\item \code{ru_idrss} (character) - integral unshared data size (in kB) [UNUSED]
\item \code{ru_isrss} (character) - integral unshared stack size (in kB) [UNUSED]
\item \code{ru_minflt} (numeric) - page reclaims (soft page faults)
\item \code{ru_majflt} (numeric) - page faults (hard page faults)
\item \code{ru_nswap} (numeric) - number of swaps [UNUSED]
\item \code{ru_inblock} (numeric) - number of block input operations
\item \code{ru_oublock} (numeric) - number of block output operations
\item \code{ru_msgsnd} (numeric) - number of IPC messages sent [UNUSED]
\item \code{ru_msgrcv} (numeric) - number of IPC messages received [UNUSED]
\item \code{ru_nsignals} (numeric) - number of signals received
\item \code{ru_nvcsw} (numeric) - number of voluntary context switches (number of
times a context switch resulted due to a process voluntarily giving up
the processor before its time slice was completed (usually to await
availability of a resource)
\item \code{ru_nivcsw} (numeric) - number of involuntary context switches (number of
times a context switch resulted due to a higher priority process becoming
runnable or because the current process exceeded its time slice)
\item \code{project} (character) -
\item \code{department} (character) -
\item \code{granted_pe} (character) - the parallel environment which was selected
for the job
\item \code{slots} (integer) - the number of slots which were dispatched to the job
by the scheduler
\item \code{task_number} (integer) -
\item \code{cpu} (drtn) - The CPU time usage (in seconds)
\item \code{mem} (character) - the integral memory usage (in GB seconds)
\item \code{io} (character) - the amount of data transferred in input/output
operations (in GB) if available, otherwise \code{0}
\item \code{category} (character) -
\item \code{iow} (drtn) - the input/output wait time (in seconds) if available,
otherwise 0
\item \code{pe_taskid} (character) - if this identifier is not equal to \code{NONE}, the
task was part of parallel job, and was passed to Grid Engine via the
\code{qrsh}-inherit interface
\item \code{maxvmem} (numeric) - the maximum vmem size (in bytes)
\item \code{arid} (numeric) - advance reservation identifier
\item \code{ar_sub_time} (dttm) - advance reservation submission time, if the job
uses the resources of an advance reservation, otherwise \code{0}
}

A \code{tibble} data frame with columns corresponding to the requested
properties.

A tibble
}
\description{
Read a tab-delimited SGE accounting file (without parsing it)

Coerce to an 'sge_accounting' Object

Locate the SGE Accounting File on the Current System

Read an SGE accounting

Parse SGE Accounting 'category' Field

Table of SGE failed codes with descriptions
}
\section{Location of the SGE accounting file}{

The SGE \file{accounting} file is typically located in a subfolder of
the folder \file{$SGE_ROOT/$SGE_CELL/}.  On Wynton HPC, the pathname
is given by \code{sge_accounting_file()}.
}

\section{File offset positions for each job entry}{

If you know the file offset (in bytes) for the first job entry you wish to read,
then specify it via argument \code{offset}.  This speeds up the reading, because it
avoids having to parse jobs from the beginning.  To find the file offsets for
job entries, see \code{\link[=make_file_index]{make_file_index()}}.
}

\section{Failed code}{
\tabular{rlll}{
   Code \tab Description \tab OK \tab Explanation \cr
   0 \tab no failure \tab Y \tab ran and exited normally \cr
   1 \tab assumedly before job \tab N \tab failed early in execd \cr
   3 \tab before writing config \tab N \tab failed before execd set up local spool \cr
   4 \tab before writing PID \tab N \tab shepherd failed to record its pid - filesystem problem? \cr
   6 \tab setting processor set \tab N \tab failed setting up processor set (obsolete) \cr
   7 \tab before prolog \tab N \tab failed before prolog \cr
   8 \tab in prolog \tab N \tab failed in prolog \cr
   9 \tab before pestart \tab N \tab failed before starting PE \cr
   10 \tab in pestart \tab N \tab failed in PE starter \cr
   11 \tab before job \tab N \tab failed in shepherd before starting job \cr
   12 \tab before pestop \tab Y \tab ran, but failed before calling PE stop procedure \cr
   13 \tab in pestop \tab Y \tab ran, but PE stop procedure failed \cr
   14 \tab before epilog \tab Y \tab ran, but failed before calling epilog \cr
   15 \tab in epilog \tab Y \tab ran, but failed in epilog \cr
   16 \tab releasing processor set \tab Y \tab ran, but processor set could not be released (obsolete) \cr
   17 \tab through signal \tab Y \tab job killed by signal (possibly qdel) \cr
   18 \tab shepherd returned error \tab N \tab shepherd died somehow \cr
   19 \tab before writing exit_status \tab N \tab shepherd didn't write reports correctly - probably program or machine crash \cr
   20 \tab found unexpected error file \tab ? \tab shepherd encountered a problem \cr
   21 \tab in recognizing job \tab N \tab qmaster asked about an unknown job (not in accounting?) \cr
   24 \tab migrating (checkpointing jobs) \tab Y \tab ran, will be migrated \cr
   25 \tab rescheduling \tab Y \tab ran, will be rescheduled \cr
   26 \tab opening output file \tab N \tab failed opening stderr/stdout file \cr
   27 \tab searching requested shell \tab N \tab failed finding specified shell \cr
   28 \tab changing to working directory \tab N \tab failed changing to start directory \cr
   29 \tab AFS setup \tab N \tab failed setting up AFS security \cr
   30 \tab application error returned \tab Y \tab ran and exited 100 - maybe re-scheduled \cr
   36 \tab checking configured daemons \tab N \tab failed because of configured remote startup daemon \cr
   37 \tab qmaster enforced h_rt, h_cpu, or h_vmem limit \tab Y \tab ran, but killed due to exceeding run time limit \cr
   38 \tab adding supplementary group \tab N \tab failed adding supplementary gid to job \cr
   100 \tab assumedly after job \tab Y \tab ran, but killed by a signal (perhaps due to exceeding resources), task died, shepherd died (e.g. node crash), etc. \cr
}


The following failed codes are specific to MS Windows:\tabular{rlll}{
   Code \tab Description \tab OK \tab Explanation \cr
   31 \tab accessing sgepasswd file \tab N \tab failed because sgepasswd not readable* \cr
   32 \tab entry is missing in password file \tab N \tab failed because user not in sgepasswd* \cr
   33 \tab wrong password \tab N \tab failed because of wrong password against sgepasswd* \cr
   34 \tab communicating with Grid Engine Helper Service \tab N \tab failed because of failure of helper service* \cr
   35 \tab before job in Grid Engine Helper Service \tab N \tab failed because of failure running helper service* \cr
}


Source: \verb{man sge_status}.
}

\section{Common exit codes}{
\tabular{rl}{
   Code \tab Description \cr
   0 \tab Success \cr
   1 \tab Catchall for general errors \cr
   2 \tab Misuse of shell builtins (according to Bash documentation) \cr
   126 \tab Command invoked cannot execute, e.g. \verb{/dev/null} \cr
   127 \tab "command not found" \cr
   128 \tab Invalid argument to exit, e.g. \verb{exit 3.14} \cr
   128 + n \tab Fatal error signal n \cr
   134 \tab 128 +   6 = 128 + \code{SIGABRT} - Abort signal from abort \cr
   135 \tab 128 +   7 = 128 + \code{SIGBUS}  - Bus error (bad memory access) \cr
   136 \tab 128 +   8 = 128 + \code{SIGFPE}  - Floating-point exception \cr
   137 \tab 128 +   9 = 128 + \code{SIGKILL} \cr
   138 \tab 128 +  10 = 128 + \code{SIGUSR1} \cr
   140 \tab 128 +  12 = 128 + \code{SIGUSR2} \cr
   255 \tab 128 + 127 = Exit status out of range, e.g.\code{exit -1} \cr
}


Comment: \code{exit} only takes integers in [0,255]
}

\section{Benchmarking}{

The \file{accounting} on Wynton HPC took ~2 minutes to read when it
was 4.8 GB in size and ~6-8 minutes when it was 12 GB in size.
}

\examples{
pathname <- system.file("exdata", "accounting", package = "wyntonquery")

jobs <- read_raw_sge_accounting(pathname)
print(jobs)

## Anonymize (although actually already anonymized)
jobs_anon <- anonymize(jobs)
print(jobs_anon)
pathname <- system.file("exdata", "accounting", package = "wyntonquery")

jobs <- read_sge_accounting(pathname)
print(jobs)
## # A tibble: 1,000 x 45
##    qname    hostname group  owner   job_name job_number account priority submission_time    
##    <chr>    <chr>    <chr>  <chr>   <chr>         <int> <chr>      <int> <dttm>             
##  1 member.q cin-id3  group4 owner09 sleep.sh          1 sge            0 2017-08-15 11:59:21
##  2 long.q   cc-id2   group4 owner09 sleep.sh          2 sge           19 2017-08-15 12:00:23
##  3 long.q   cc-id2   group4 owner09 sleep.sh          2 sge           19 2017-08-15 12:00:23
## ...

## Identify successful and failed jobs
jobs_success <- subset(jobs, failed == 0)
jobs_fail <- subset(jobs, failed > 0)

## CPU time consumed
t <- c(sum(jobs_success$cpu), sum(jobs_fail$cpu))
units(t) <- "days"
print(t)
## Time differences in days
## [1] 1283.6721  328.9508

## Fraction of successful and failed CPU time
u <- as.numeric(t)
u <- u / sum(u)
names(u) <- c("success", "failed")
print(u)
##   success    failed 
## 0.7960151 0.2039849
}
\references{
\itemize{
\item \verb{man accounting}
\item \verb{man sge_status}
}
}
